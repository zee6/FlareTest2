<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="8" MadCap:lastHeight="8337" MadCap:lastWidth="1196">
    <head><title></title>
        <link href="../Resources/Stylesheets/Collab_Srvr_Concise_Setup_CSS.css" rel="stylesheet" />
    </head>
    <body>
        <h1 class="Heading1">
            <MadCap:concept term="Co-browsing" />Universal and Document Co-browsing (Optional)</h1>
        <p>The information on this page assumes you are already familiar with how to set up and configure an unblu collaboration server. See <a href="WJAR Deployment Collaboration Server Setup.htm">Unblu Server Setup</a> and <a href="unblu Server Configuration.htm">Unblu Server Configuration</a>.</p>
        <p>In order to be able to use universal co-browsing and/or document sharing in an unblu collaboration server running on your application server, the unblu/renderingservice appliance is required.</p>
        <p>Document co-browsing and universal co-browsing require the unblu Rendering Service appliance to be installed. <span class="Bolder">The unblu Rendering Service is based on Docker</span> (<a href="https://www.docker.com/">https://www.docker.com/</a>). It requires a separate host to run Docker with the rendering service Docker image available at <a href="https://hub.docker.com/r/unblu/renderingservice/">https://hub.docker.com/r/unblu/renderingservice/</a></p>
        <p>For more information on how to install and run a docker engine visit <a href="https://www.docker.com/">https://www.docker.com/</a>.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Docker Explained</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Docker is a container system that is used to supplement and augment virtualization. Docker automates the deployment of <a href="https://en.wikipedia.org/wiki/Application_software">applications</a> inside <a href="https://en.wikipedia.org/wiki/Software_container">software containers</a>. Docker containers wrap up a piece of software in a complete filesystem that contains everything it needs to run: code, runtime, system tools, system libraries – anything you can install on a server. This guarantees that it will always run the same, regardless of the environment it is running in.</p>
                <p><a href="https://docker.io/">https://docker.io</a> - Explanation of the technology behind Docker containers, Docker hosts etc.</p>
                <p><a href="https://docs.docker.com/">https://docs.docker.com</a> - Detailed documentation on all aspects of Docker.</p>
                <p><a href="https://hub.docker.com/">https://hub.docker.com</a> - Platform for companies and open source communities around the world to provide and share Docker images.</p>
                <p><a href="https://hub.docker.com/r/unblu/renderingservice/">https://hub.docker.com/r/unblu/renderingservice/</a> - The unblu rendering service Docker image, which must be used for universal co-browsing.</p>
                <p>Unblu does not load the complete software into the Docker hub; only the unblu-prepared image of Linux. The unblu functionality is at the time of delivery, and after the installation, held exclusively within the unblu collaboration server.</p>
                <p>When you start the unblu renderingservice Docker image in the dock host, the image becomes a container. After starting, the container is contacted by the unblu collaboration server via SSH and the rendering service application is "uploaded". As soon as the application is started, it connects again via http or https (as required) back to the server and is ready for use.</p>
                <p>The Docker image "unblu renderingservice" makes it possible to start a "partitioned Linux" which shares the Linux kernel of the host system. For this purpose, a so-called "Docker image" which defines what is part of the "isolated" Linux is created.</p>
                <p>The unblu rendering service was fine-tuned on OpenSUSE and requires predefined packages (fonts, libraries etc.). Since not every customer is able to use OpenSUSE, or because it is complex to prepare the packages "manually" for the different systems, unblu decided instead to create a Docker image, which is based on the official OpenSUSE image and pre-installed packages. The fact that the image is based on OpenSUSE and exactly what packets are used is not carved in stone. It is possible that unblu could change the content of the rendering service image in future releases.</p>
                <p>It is best to imagine the image as an "appliance" or "black box". This does not mean that unblu has secrets regarding the image - on the contrary; since our image is in the Docker hub, everyone can download and examine it. unblu adjusts the content of the image as needed. This is, of course, only within the scope of new releases. Docker images have "tags" that define to which unblu release they belong.</p>
                <p><span style="background-color: #f5deb3;">Nevertheless, it is possible that the tools used have, for example, OpenSUSE vulnerabilities. For this reason our image is based on OpenSUSE. The distribution ensures that OpenSUSE releases not only ISO releases or Update Manager packets but also new Docker images. Unblu, on the other hand, rebuilds its own image on a regular basis, so that the problems fixed by OpenSUSE are also fixed in unblu.</span>
                </p>
                <p>It is therefore recommended to refer to the unblu renderingservice image directly from the Docker Hub, since that is the only place where there is a regular update.</p>
                <p>However, if this is perceived as too uncertain, there is also the possibility to order the Docker image directly from us - but this is currently not possible on a regular basis; only on request.</p>
                <p><span class="Bolder">Docker Q &amp; A</span>
                </p>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">How does unblu ensure that the image is safe from abuse and/or change?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>We have an account at Docker hub and can provide our images in this context. The security of this account is highly dependent on the operation of the Docker hub, which is not in our hands. (Nevertheless, it should be be noted that many well-known, and large, companies provide their images on Docker.)</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">How can we be sure that the correct software is always downloaded?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>It is not the complete unblu functionality but "just" a basic Linux image. Basically, Docker ensures that the transfer is correct and the imageInteger is correct when it has been loaded. The images can / should not be downloaded "by hand" but with the help of the docking tools, thus guaranteeing security.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <p><i style="background-color: #f5deb3;">If files / patches are signed resp. The images "ge-hashed": This is one of the central tasks of Docker resp. Docker hub.</i>
                </p>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">What is the Docker Hub URL?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p><a href="https://hub.docker.com/r/unblu/renderingservice">https://hub.docker.com/r/unblu/renderingservice</a>
                        </p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">How do I access the Docker image?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>Using the "Docker pull unblu / renderingservice" command on the Docker host. Alternatively, the image can also be loaded on a different system then exported and imported again onto the final Docker host. In this case the Docker host would not need access to the Docker hub.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Do other banks use the Docker solution?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>Yes. Docker's usage numbers are going through exponential growth with over two billion 'pulls'. Docker (the company) claims that their sales pipeline is 'disproportionately' filled with finance companies.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Is there a Docker whitepaper?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>Yes, the Docker docs are excellent: <a href="https://docs.docker.com/">https://docs.docker.com</a></p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Has the Docker hub been checked by an external company?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>Docker itself is usually integrated as a "strategic decision" by a company's IT department. In the context of such a decision it may be that such reviews take place - but this has nothing to do with unblu. To this extent, unblu does not know what customers have clarified beforehand.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Is it possible to get the Docker image directly from unblu?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>Yes, as mentioned above, but not at regular (automated) intervals: only on request.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Is Unblu's Docker image signed (keyword content trust)?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>We have the unblu / renderingservice 4.2 Docker image actually signed and thus Docker's content trust in operation. Content trust is therefore implemented and available according to the Docker documents.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Does the Docker host system run anything other than the Unblu Docker container?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>The Docker host system is set by the client or agents of the client. This question must be answered by the client.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Does the Docker host system check the certificate of the Docker Hub server (Certificate Pinning)?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>The loading of the Docker image from the Docker hub is carried out by means of Docker pull functionality. As far as we can gather, it is currently only checking whether it has been signed by a trustworthy CA - but there seem to be initiatives to explicitly define CAs that are allowed <span style="background-color: #f5deb3;">resp. </span>Even to define your own client certificates.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Is it confirmed by Unblu that no data is transferred from the rendering server to the Docker solution during uploading?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>The Docker host has to download the Docker image with Docker pull and then start. Alternatively, Docker pull can be run on a separate machine, export the image, transfer it to the Docker host, and then start it. This process can be seen as an "installation process" and has nothing to do with the operation of unblu itself. The step is similar to setting up a virtual machine where the image is loaded from a central location.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Does Unblu call any Docker commands?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>During the operation of pages no communication with the Docker hub takes place (neither with the collaboration server nor the rendering service).</p>
                        <p>In ongoing operations there is a connection between the unblu collaboration server and the docking container (rendering service) via SSH. The Collaboration Server uses this connection to extract the rendering service from itself at the start and to transfer it to the Docker container. Subsequently, the rendering service is started in the container (again via ssh) from the collaboration server. This connects to https back to the collaboration server. The rendering service will then connect to those sites that are to be viewed together for the co-browsing in a running universal co-browsing session.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">Will this proxy-enabled (Rendering-Server-to-Docker) connection hinder us from controlling this access via the McAfeeWeb gateway?</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p>This point contradicts the question / request of Compass (certificate pinning) McAfeeWeb gateway as "Man in the middle" or more precisely; opposite clients from the internal network as SSL endpoint. If this is the case, the client use their own SSL certificates and certificate pinning is not possible. To solve this problem it would be advisable to load the Docker image from the Docker hub on a separate server (which has special access rights to the Docker hub server without running over the McAfeeWeb Gateway) and then internally to the dock host transfer.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot><span class="Bolder">If the Docker container is updated automatically on the rendering server, it is automated or aborted.</span>
                        </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p style="background-color: #f5deb3;">All Docker-specific actions must be initiated by the administrator (or by appropriate administrator scripts or infrastructure tool such as Puppet etc.). unblu does not use Docker commands. In order to update the Docker container it is necessary to regularly "Docker pull" and to start the Docker container.</p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Universal Versus Embedded  Co-browsing</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Embedded co-browsing is where we capture the Document Object Model (DOM), images and style sheets using the unblu Filter and the visitor stays inside their browser while we use JavaScript to replicate the browser on the agent side.</p>
                <p>Universal co-browsing is where a headless browser runs on our server inside the rendering service and we render the graphical output to both the agent and visitor.</p>
                <p><span class="Bolder">Note:</span> Context sharing is not possible with universal co-browsing. Context sharing means that visitors do not lose their login or shopping cart information when they start co-browsing.</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot><a name="Enable"></a>
                    <MadCap:concept term="Co-browsing" />Enable Universal and Document Co-browsing (Optional)</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>The unblu rendering service appliance is a helper appliance that augments the unblu Collaboration Server with the capability to perform universal co-browsing and document sharing.</p>
                <p>
                    <img src="../Resources/Images/Server_Setup_Guide_Pictures/Enable Universal and Document.png" style="mc-thumbnail: popup;mc-thumbnail-max-height: 400px;" class="img_1" />
                </p>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot>Network Connectivity Requirements to run the Rendering Service</MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <MadCap:dropDown>
                            <MadCap:dropDownHead>
                                <MadCap:dropDownHotspot>SSH unblu Collaboration Server to the unblu Rendering Service</MadCap:dropDownHotspot>
                            </MadCap:dropDownHead>
                            <MadCap:dropDownBody>
                                <p>The unblu Collaboration Server must be able to connect to the unblu rendering service using the SSH protocol on a tcp port on the Docker host that is mapped to the tcp port 22 in the unblu Rendering Service container.</p>
                            </MadCap:dropDownBody>
                        </MadCap:dropDown>
                        <MadCap:dropDown>
                            <MadCap:dropDownHead>
                                <MadCap:dropDownHotspot>HTTP(s) from the unblu rendering service to the unblu Collaboration Server</MadCap:dropDownHotspot>
                            </MadCap:dropDownHead>
                            <MadCap:dropDownBody>
                                <p>The unblu Rendering Service container must be able to connect to the unblu Collaboration Server using http(s) with the URL provided in the <code>com.unblu.hbworker.headlessBrowserReverseBaseUrl</code> configuration property.</p>
                            </MadCap:dropDownBody>
                        </MadCap:dropDown>
                        <MadCap:dropDown>
                            <MadCap:dropDownHead>
                                <MadCap:dropDownHotspot>HTTP(S) unblu Rendering Service to Internet / Intranet</MadCap:dropDownHotspot>
                            </MadCap:dropDownHead>
                            <MadCap:dropDownBody>
                                <p>If the unblu Rendering Service is used for universal co-browsing then the unblu rendering service container needs to be able to access all web servers (using HTTP(S)) that need to be available within universal co-browsing. Note that this requirement does not apply when the rendering service is only used for document sharing.</p>
                            </MadCap:dropDownBody>
                        </MadCap:dropDown>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot><a name="Configure_and_run_the_Rendering_Service_Appliance"></a>Configure and Run the Rendering Service Appliance</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>The unblu rendering service appliance is installed / started using the Docker command line tool with the following command:</p><pre class="prettyprint" xml:space="preserve"><span class="Bolder"># Create and start the rendering service container</span>
# &lt;name&gt;: name of the docker container that is created on the docker  
# host 
# &lt;port&gt;: tcp port mapping for the unblu/renderingservice on the docker # host 
#         (the unblu collaboration server will connect to the
#          unblu/renderingservice through this tcp port)
# &lt;password&gt;: password for the unblu collaboration server to connect to
#             the unblu/renderingservice
docker run -d --name &lt;name&gt; -p &lt;port&gt;:22 -e PASSWORD=&lt;password&gt; unblu/renderingservice</pre>
                <p>This command creates and starts a container from the unblu rendering service image on the Docker host.</p>
                <p>To stop the rendering service container:</p><pre class="prettyprint" xml:space="preserve"><span class="Bolder"># Stopping the rendering service container</span>
# &lt;name&gt;: name of the docker container as given in the "docker run" command above
docker stop &lt;name&gt;</pre>
                <p>and to start the container again:</p><pre class="prettyprint" xml:space="preserve"><span class="Bolder"># Starting the rendering service container</span>
# &lt;name&gt;: name of the docker container as given in the "docker run" command above
docker start &lt;name&gt;</pre>
                <p>The unblu rendering service Docker image is stateless and does not store any persistent data, thus it is also possible to use a transient container (create a new container on every start of the system) instead of using a persistent container.</p>
                <p>If you want to remove the rendering service use the following command:</p><pre class="prettyprint" xml:space="preserve"><span class="Bolder"># Stop and remove the rendering service</span>
# &lt;name&gt;: name of the docker container as given in the "docker run" command above
docker -t 10 stop &lt;name&gt;; docker rm -f &lt;name&gt;</pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Configure the unblu Collaboration Server to use the unblu Rendering Service</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>With the rendering service started you can configure the unblu Collaboration Server to use it with the following configuration properties:</p><pre class="prettyprint"># &lt;collaborationServerBaseUrl&gt;: fully qualified base url of the unblu 
#          collaboration server (reachable from the renderingservice), 
#          i.e. https://unbluserver.mycompany.com 
#          (format: &lt;protocol&gt;://&lt;host&gt;[:&lt;optionalPort&gt;]
# &lt;dockerHost&gt;: host name or IP of the docker host where the unblu/renderingservice 
#               container is running
# &lt;renderingServicePort&gt;: tcp port of the unblu/renderingservice container 
#                         as mapped using the -p &lt;renderingServicePort&gt;:22 
#                         argument in the "docker run" command
# &lt;password&gt;: the password of the unblu/renderingservice
com.unblu.hbrunner.runnerStrategy=HB_RUNNER_POOL_SINGLE_VA
com.unblu.hbworker.headlessBrowserReverseBaseUrl=&lt;collaborationServerBaseUrl&gt;/sys-unblu
com.unblu.hbrunner.vaHostname=&lt;dockerHost&gt;
com.unblu.hbrunner.vaSSHPort=&lt;renderingServicePort&gt;
com.unblu.hbrunner.vaPassword=&lt;password&gt;</pre>
                <p>While the above block deals with the technical requirements to establish connections between the unblu Collaboration Server and the rendering service, the following property is required to enable universal and document co-browsing in unblu as a whole:</p><pre class="prettyprint"># enable universal co-browsing options in agent desk
com.unblu.collaborationsession.headlessBrowserEnabled=true</pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Test Connectivity of Docker to Collaboration Server</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Once Docker has been started with docker run (see above), try to connect from the unblu Collaboration Server into Docker as follows:</p><pre class="prettyprint">Connecting to the docker image
# &lt;port&gt;: port on which docker host is providing access to the image 
#         (corresponds to &lt;port&gt; from docker run command)
# &lt;dockerHost&gt;: host name or IP of the docker host where the 
#               unblu/renderingservice container is running
# &lt;password&gt;: the password specified when starting the unblu rendering service 
#             with docker run
ssh -p &lt;port&gt; unblu@&lt;dockerHost&gt;
Password: &lt;password&gt;</pre>
                <p>Within the Docker image you should also check whether the connection back to the unblu Collaboration Server works. For that purpose make sure the unblu Collaboration Server has been successfully started. Once it is started, login to the Docker image using ssh (see above) and execute the following:</p><pre class="prettyprint">Connecting back to collaboration server
# &lt;collaborationServerBaseUrl&gt;: fully qualified base url of the unblu collaboration server. 
#                               Must eventually match with what's specified in the 
#                               unblu.properties file 
#                               (see com.unblu.hbworker.headlessBrowserReverseBaseUrl 
#                               above) 
curl &lt;collaborationServerBaseUrl&gt;/sys-unblu/rest/product/all
 
# example output from the above command:
product.com.unblu.core_4.1.7.RELEASE 
product.com.unblu.headlessbrowser.model_0.0.1 
product.com.unblu.thirdparty_1.0.0 
product.com.unblu.enterprise.universe.base_4.1.7.RELEASE 
product.com.unblu.domcap_0.0.1 
product.com.unblu.dispatcher_3.0.0 
product.com.unblu.filemanager_0.0.1 
product.com.unblu.platform_2.0.2 
product.com.unblu.proxy_1.0.3 
product.com.unblu.runtime.jetty_1.0.3 
product.com.unblu.node_4.1.7.RELEASE 
product.com.unblu.cloud.storage.immutable_3.0.0 
product.com.unblu.zookeeper_3.3.3 
product.com.unblu.enterprise.universe.staticusers_4.1.7.RELEASE MAIN
product.com.unblu.chat_0.0.1 
product.com.unblu.authenticator_3.0.0 
product.com.unblu.cassandra_1.2.18 
product.com.unblu.headlessbrowser_0.0.1 </pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Diagnostic Tools</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Some other network diagnostic tools that may help to analyze problems when you are connected with SSH into the unblu Docker image (example):</p><pre class="prettyprint">Example diagnostic tools
# check if dns lookups work
# &lt;collaborationServerHostname&gt;: Hostname or IP of the unblu collaboration server
nslookup &lt;collaborationServerHostname&gt;
 
# check if ping works. Note: must be called with sudo. Operation is not permitted otherwise.
# &lt;collaborationServerHostname&gt;: Hostname or IP of the unblu collaboration server
sudo ping &lt;collaborationServerHostname&gt; </pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>&#160;</p>
    </body>
</html>